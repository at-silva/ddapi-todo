const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const { Parser } = require("acorn");
const walk = require("acorn-walk")

function getQueries(fileContent, filePath) {
    const myParser = Parser.extend(
        require("acorn-jsx")()
    );

    const ast = myParser.parse(fileContent, {
        //TODO: parameterize
        sourceType: "module",
        ecmaVersion: 2020
    });
    const queries = [];

    walk.simple(ast, {
        ObjectExpression(node) {
            const [ddapiIdProp] = node.properties.filter(p => p.key.name === 'DDAPIID');
            if (!ddapiIdProp) {
                return
            }
            const [sqlProp] = node.properties.filter(p => p.key.name === 'sql');
            const [paramsSchemaProp] = node.properties.filter(p => p.key.name === 'paramsSchema');

            if (!sqlProp || !paramsSchemaProp) {
                console.warn(`[DDAPI] found DDAPIID property but couldn't find 'sql' or 'paramsSchema' properties at ${filePath}`);
                return
            }

            queries.push([
                fileContent.substring(ddapiIdProp.start, ddapiIdProp.end),
                fileContent.substring(sqlProp.start, sqlProp.end),
                fileContent.substring(paramsSchemaProp.start, paramsSchemaProp.end)
            ]);
        }
    })

    return queries;
}

async function* walkDir(dir) {
    for await (const d of await fs.promises.opendir(dir)) {
        const entry = path.join(dir, d.name);
        if (d.isDirectory()) {
            yield* walkDir(entry)
        } else if (d.isFile()) {
            yield entry;
        }
    }
}

function getHash(value) {
    //TODO: parameterize 
    if (process.env.DDAPI_TODO_SECRET === "") {
        console.error("[DDAPI] DDAPI_TODO_SECRET is not set")
        return
    }
    //TODO: parameterize
    let hmac = crypto.createHmac('sha256', process.env.DDAPI_TODO_SECRET);
    let data = hmac.update(value);
    return data.digest('base64');
}

// TODO: refactor into a npm module
async function run() {
    let signatures = {};
    let paths = {};

    //TODO: parameterize the path
    for await (const filePath of walkDir('src/')) {
        //TODO: refactor to remove the hardcoded file names
        if (filePath.endsWith('sign.js') || filePath.endsWith('ddapi/index.js')) {
            continue;
        }

        const fileContent = fs.readFileSync(filePath).toString();
        if (fileContent.includes("DDAPIID")) {
            for (const query of getQueries(fileContent, filePath)) {
                const [ddapiIdText, sqlText, paramsSchemaText] = query;
                const ddapiId = eval(`({${ddapiIdText}})`).DDAPIID;
                const sql = eval(`({${sqlText}})`).sql;
                const paramsSchema = eval(`({${paramsSchemaText}})`).paramsSchema;
                console.info(`[DDAPI] calculating hash for ${ddapiId}`);
                signatures[`${ddapiId}_sql`] = getHash(sql);
                signatures[`${ddapiId}_params_schema`] = getHash(JSON.stringify(paramsSchema));
                paths[`${ddapiId}_sql`] = filePath;
                paths[`${ddapiId}_params_schema`] = filePath;
            }
        }
    }

    let signaturesContent = `// DO NOT EDIT THIS FILE: this is an auto-generate file
export const DDAPI_SIGNATURES = {`
    let path;
    for (const key in signatures) {
        if (paths[key] !== path) {
            path = paths[key];
            signaturesContent += `\n\t// ${path}`
        }
        signaturesContent += `\n\t"${key}": "${signatures[key]}",`;
    }
    signaturesContent += "\n};";

    // TODO: parameterize
    fs.writeFileSync('src/ddapi/signatures.js', signaturesContent);

    console.info('[DDAPI] pronto!');
}


run();